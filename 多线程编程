    在多线程（multithread，MT）编程出现之前，计算机程序的执行是由单个步骤序列组成的，该序列在主机的CPU中按照同步顺序执行。无论是任务本身需要按照步骤顺序执行，还是整个程序实际上包含多个子任务，都需要按照这种顺序方式执行。
    多线程编程对于具有如下特点的编程任务而言是非常理想的：本质上是异步的；需要多个并发活动；每个活动的处理顺序可能是不确定的，或者说是随机的、不可预测的。这种编程任务可以被组织或划分成多个执行流，其中每个执行流都有一个指定要完成的任务。根据应用的不同，这些任务可能需要计算出中间结果，然后合并最终的输出结果。
    计算密集型的任务可以比较容易的划分出多个任务，然后按顺序执行或按照多线程方式执行。而那种使用单线程处理多个外部输入源的任务就不那么简单了。如果不使用多线程方式执行，要实现这种编程任务就需要为串行程序使用一个或多个计时器，并实现一个多路复用的方案。
    一个串行程序需要从每个I/O终端通道来检查用户的输入；然而，有一点非常重要，程序在读取I/O终端通道时不能阻塞，因为用户输入的到达时间是不确定的，并且阻塞会妨碍其他的I/O通道的处理。串行程序必须使用非阻塞I/O或拥有计时器的阻塞I/O（以保证阻塞只是暂时的）。
    因为串行程序只有唯一的执行线程，因此它必须兼顾需要执行的多个任务，确保其中的某个任务不会占用过多时间，并对用户的响应时间进行合理的分配。这种任务类型的串行程序的使用，往往造成非常复杂的控制流，难以理解和维护。
    使用多线程编程，以及类似Queue的共享数据结构，这个编程任务可以规划成几个执行特定函数的线程。
    UserRequestThread：负责读取客户端输入，该输入可能来自I/O通道。程序将创建多个线程，每个客户端一个，客户端的请求将会被放入队列中。
    RequestProcessor：该线程负责从队列中获取请求并进行处理，为第三个线程提供输出。
    ReplyThread：负责向用户输出，将结果传回给用户，或者把数据写到本地文件或数据库中。
    使用多线程来规划这种编程任务可以降低程序的复杂性，使其实现更加清晰、高效、简洁。每个线程中的逻辑都不复杂，因为它只有一个要完成的特定作业。比如，UserRequestThread的功能仅仅是读取用户的输入，然后把输入数据放到队列里，以供其他线程后续处理。每个线程都有其明确的作业。
    
    进程：
    计算机程序只是存储在磁盘上的可执行二进制（或其他类型）文件。只有把它们加载到内存中并被操作系统调用，才拥有其生命周期。进程（有时称为重量级进程）则是一个执行中的程序。每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上所有进程的执行，并为这些进程合理地分配时间。进程也可以通过派生（fork 或 spawn）新的进程来执行其他任务，不过因为每个新进程也都拥有自己的内存和数据栈等，所以只能才用进程间通信（IPC）的方式共享信息。
    线程：
    线程（有时候称为轻量级进程）与进程相似，不过它们是在同一个进程下执行的，并共享相同的上下文。可以将它们认为是在一个主进程或“主线程”中并行运行的一些“迷你进程”
    线程包括开始、执行顺序和结束三部分。它有一个指令指针，用于记录当前运行的上下文。当其他线程运行时，它可以被抢占（中断）和临时挂起（也称为睡眠）---这种做法叫做让步（yielding）。
    一个进程中的各个线程与主线程共享同一片数据空间，因此相比于独立的进程而言，线程间的信息共享和通信更加容易。线程一般是以并发方式执行的，正是由于这种并行和数据共享机制，使得更多任务间的协作成为可能。当然，在单核CPU系统中，因为真正的并发是不可能的，所以线程的执行实际上时这样规划的：每个线程运行一小会儿，然后让步给其他线程（在此排队等待更多的CPU时间）。在整个进程的执行过程中，每个线程执行它自己特定的任务，在必要时和其他线程进行结果通信。
    当然，这种共享并不是没有风险的。如果两个或多个线程访问同一片数据，由于数据访问顺序不同，可能导致结果不同。这种通常称为竞态条件（race condition）。幸运的是大多数线程库都有一些同步原语，以允许线程管理器控制执行和访问。
    另一个需要注意的是，线程无法给予公平的执行时间。这是因为一些函数会在完成前保持阻塞状态，如果没有专门为多线程情况进行修改，会导致CPU的时间分配向这些贪婪的函数倾斜。
    
    线程和Python
    全局解释器锁：
    Python 代码的执行是由Python 虚拟机进行控制的。Python在设计时是这样考虑的，在主循环中同时只能有一个控制线程在执行，就像单核CPU系统中的多进程一样。内存中可以有许多程序，但是任一时间只能有一个程序在运行。同理，尽管Python解释器中可以运行多个线程，但是在任意时间只有一个线程被解释器执行。
    对Python虚拟机的访问是由全局解释器锁（GIL）控制的。这个锁就是用来保证同时只能有一个线程运行的。在多线程环境中，Python虚拟机将按照下面所述的方式执行。
    1.设置GIL
    2.切换进一个线程去运行
    3.执行下面的操作之一
        a.指定数量的字节码指令
        b.线程主动让出控制权（可以调用time.sleep(0）来完成)。
    4.把线程设置回睡眠状态（切换出线程）
    5.解锁GIL
    6.重复上述步骤
    当调用外部代码（即，任意C/C++扩展的内置函数）时，GIL会保持锁定，直至函数执行结束（因为在期间没有Python字节码计数）。编写扩展函数的程序员有能力解锁GIL，然而，作为Python开发者，你并不担心Python代码会在这些情况下被锁住。
    I/O密集型的Python程序要比计算密集型的代码能够更好地利用多线程环境。
    
    退出线程：
    当一个线程完成函数的执行时，它就会退出。另外，还可以通过调用诸如thread.exit()之类的退出函数，或者sys.exit()之类的退出Python进程的标准方法，亦或者抛出SystemExit异常，来使线程退出。不过，你不能直接“终止”一个线程。
    在Python 的两个模块中不建议使用thread模块。给出这个建议的很多原因，最明显的一个原因是在主线程退出后，所有其他线程都会在没有清理的情况下直接退出。而另一个模块threading会确保在所有“重要的”子线程退出前，保持整个进程的存活。
    
    python 提供了多个模块来支持多线程，包括thread、threading和Queue模块等。程序是可以使用thread和threading模块来创建与管理线程。thread模块提
供了基本的线程和锁定支持；而threading模块提供了更高级别、功能更全面的线程管理。使用Queue模块，用户可以创建一个队列数据结构，用于在多线程
之间进项共享。

    thread 模块（python 3不再支持thread）
    除了派生线程外，thread模块还提供了基本的同步数据结构，称为锁对象（lock object，也叫原语锁、简单锁、互斥锁、互斥和二进制信号量）。这个同步原语和线程管理是密切相关的。
    常用的线程函数:
    start_new_thread(function,args,kwargs=None) 派生一个新的线程，使用给定的args和可选的kwargs来执行funtion
    allocate_lock() 分配LockType锁对象
    exit() 给线程推出指令
    
    LockType锁对象的方法:
    acquire(wait=None) 尝试获取锁对象
    locked() 如果获取了锁对象则返回True，否则，返回False
    release() 释放锁
    
    threading模块
    除了Thread类之外，还包含许多非常好用的同步机制
    threading模块对象：
    Thread 表示一个执行线程对象
    Lock 锁原语对象（和thread中的锁一样）
    RLock 可重入锁对象，使单一线程可以（再次）获得已持有的锁（递归锁）
    Condition 条件变量对象，使得一个线程等待另一个线程满足特定的“条件”，比如改变状态或某个数据值
    Event 条件变量的通用版本，任意数值的线程等待某个事件的发生，在该事件发生后所有线程被激活
    Semaphore 为线程间共享的有限资源提供一个“计数器”，如果没有可用资源时会被阻塞
    BounderSemaphore 与Semaphore相似，不过它不允许超过初始值
    Timer 与Thread 相似，不过它要在运行前等待一段时间
    Barrier 创建一个“障碍”，必须达到指定数量的线程后才可以继续
    
    使用Thread类来实现多线程，是threading模块的主要执行对象，它有thread模块中没有的很多函数
    Thread对象的属性和方法：
    name 线程名
    ident 线程的标识符
    daemon 布尔标志，表示这个线程是否是守护线程
    
    __init__(group=None,target=None,name=None,args=(),kwargs={},verbose=NOne,daemon=None) 实例化一个线程对象，需要一个可调用的target，以及其参数args，kwargs。还可以传递name或这group参数，verbose标识也是可接受的，而daemon的值将会被设定为thread.daemon属性/标识
    start() 开始执行该线程
    run() 定义线程功能的方法（通常在子类中被应用开发者重写）
    join(timeout=None) 直至启动的线程终止之前一直挂起；除非给出了timeout秒，否则会一直阻塞
    getName() 返回线程名 
    setName(name) 设置线程名 getName 和setName 已经弃用，更好的是设置thread.name属性，或者在实例化过程中传递该属性
    isAlive/is_alive 布尔标识，表示这个线程是否还活着
    isDaemon() 如果是守护线程，则返回True
    setDaemon(daemonic) 把线程的守护标识设定为布尔值daemonic(必须在线程start()之前调用) ，已经弃用，应当设置thread.daemon属性；从3.3版本起也可选daemon值实例化过程中设定thread.deamon属性。
    
    使用Thread类，可以有很多方法来创建线程，主要介绍比较相似的三种方法。选择其一种作为自己主要使用的方法：
    创建Thread的实例，传给它一个函数
    创建Thread的实例，传给它一个可调用的类实例。
    派生Thread的实例，并创建子类的实例。
    一般倾向于最后一种：派生Thread的实例，并创建子类的实例。
    
    创建Thread的实例，传给它一个函数：
    实例化每个Thread对象时，把函数（target）和参数（args）传进去，然后得到返回的Thread实例。实例化Thread（调用Thread()）和调用thread.start_new_thread()的最大区别是新线程不会立即开始执行。这是一个非常有用的同步功能，尤其是当希望线程不要立即执行时。
    当所有的线程都分配完成之后，通过调用每个线程的start()方法让他们开始执行，而不是在这之前就执行。相比于管理一组锁而言，这里只需要位每个线程调用join()方法即可。join()方法将等待线程结束，或者在提供了超时时间的情况下，达到超时时间。使用join()方法要比等待锁释放的无线循环更加清晰（这也是这种锁称为自旋锁的原因）。
    对于join()方法而言，其另一个重要方面是其实它根本不需要调用。一旦线程启动，它们就会一直执行，直到给定的函数完成后退出。如果主线程还有其他事情要做，而不是等待这些线程完成，就可以不调用join()，join()方法只有在你需要等待线程完成的时候才是有用的。
    
    创建Thread的实例，传给它一个可调用的类实例：
    主要添加了ThreadFunc类，并在实例化Thread对象时同时实例化ThreadFunc。实际上，这里完成了两个实例化。让我们仔细看看ThreadFunc类吧。
    我们希望这个类更加通用，而不是局限于loop()函数，因此添加了一些新的东西，比如让这个类保存了函数的参数、函数自身以及函数名的字符串。而构造函数__init__()用于设定上述这些值。
    当创建新线程时，Thread类的代码将调用ThreadFunc对象，此时会调用__call__()这个特殊方法。由于我们已经有了要用到的参数，这里就不需要再将其传递给Thread()的构造函数了，直接调用即可。
    
    派生Thread的实例，并创建子类的实例：
    要调用Thread()的子类，和上一个创建可调用类的例子相似，当创建线程时使用子类要相对更容易阅读
    将Thread子类化，并不是直接对其实例化
    子类的构造函数必须先调用其基类的构造函数，子类中必须要有run()函数取代特殊方法__call__()
    
    threading模块的其他函数
    activeCount()/active_count() 当前活动的Thread对象数
    current_thread() 返回当前Thread对象
    enumerate() 返回当前活动的Thread对象列表
    settrace(func) 为所有线程设置一个trace函数
    setprofile(func) 为所有线程设置一个profile函数
    stack_size(size=0) 返回创建的新线程的栈的大小；或为后续创建的线程设定栈的大小为size
    
    同步原语
    同步：一般在多线程代码中，总会有一些特定的函数或代码块不希望（或不应该）被多个线程同时执行，通常包括修改数据库、更新文件或其他会产生竞态条件的类似情况。回顾本章前面部分，如果两个两个线程运行的顺序发生变化，就有可能造成代码的执行轨迹或行为不相同，或者产生不一致的数据。
    这种情况就需要使用同步的情况。当任意数量的线程可以访问临界区的代码但在给定的时刻只有一个线程可以通过时，就是使用同步的时候了。Python支持多种同步类型，可以给你足够多的选择，以便选出最适合完成任务的那种类型。
    锁/互斥，以及信号量。锁是所有机制中最简单、最低级的机制，而信号量用于多线程竞争有限资源的情况。
    
    锁有两种状态：锁定和未锁定。而且它也只支持两个函数：获得锁和释放锁。
    当多线程争夺锁时，允许第一个获得锁的线程进入临界区，并执行代码。所有之后到达的线程将被阻塞，直到第一个线程执行结束，退出临界区，并释放锁。此时，其他等待的线程可以获得锁并进入临界区。不过请记住，那些被阻塞的线程是没有顺序的，胜出线程的选择是不确定的，而且还会根据python实现的不同而有所区别。
    I/O 和访问相同的数据结构都属于临界区，因此需要用锁来防止多个线程同时进入临界区。
    threading 模块的对象Lock、RLock、Condition、Semaphore和BoundedSemaphore都包含有上下文管理，也就是说可以使用with语句
    
    信号量：如前所述，锁非常易于理解和实现，也很容易决定何时需要他们。然而，如果情况更加复杂，可能需要一个更加强大的同步原语来替代锁。对于拥有有限资源的应用来说，使用信号量可能是个不错的决定。
    信号量是最古老的同步原语之一。它是一个计数器，当资源消耗时递减，当资源释放时递增。你可以认为信号量代表它们的资源可用或不可用。消耗资源使计数器递减的操作习惯上称为P(),也称为wait、try、acquire、pend或procure。相对地，当一个线程对一个资源完成操作时，该资源需要返回资源池中。这个操作一般称为V(),也称为signal、increment、release、post、vacate。Python 简化了所有的命名，采用了和锁的函数/方法一样的名字：acquire和release。信号量比锁更加灵活，因为可以有多个线程，每个线程拥有有限资源的一个实例。
    
    生产者与消费者问题和queue模块
    生产者消费者模型，演示了商品或服务的生产者生产商品，然后将其放到类似队列的数据结构中。生产商品的时间是不确定的，同样消费者消费生产者生产额商品的时间也是不确定的。
    我们使用queue模块来提供线程间通信机制，从而让线程之间可以互相分享数据。具体而言，就是创建一个队列，让生产者（线程）在其中放入商品，而消费者（线程）消费这些商品。
    queue模块属性：
    queue模块中的类：
    Queue(maxsize = 0)创建一个先入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则（没有指定最大值），为无限队列
    LifoQueue(maxsize=0）创建一个后入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则为无限队列
    PriorityQueue(maxsize=0) 创建一个优先队列。如果给定最大值，则在队列没有空间时阻塞，否则为无限队列
    queue模块中的异常：
    Empty 当对空队列调用get*()方法时抛出异常
    Full 当对满队列调用put*()方法时抛出异常
    queue对象方法：
    qsize() 返回队列大小（由于返回时队列大小可能被其他线程修改，所以该值为近似值）
    empty() 如果队列为空，则返回True；否则返回False
    full() 如果队列为满，则返回True，否则返回False
    put(item,block=True,timeout=None) 将item放入队列。如果block为True（默认）且timeout 为None，则在有可用空间之前阻塞；如果timeout为正值，则最多阻塞timeout秒；如果block为False，则抛出Empty异常
    put_nowait(item) 和put(item,False)相同
    get(block=True,timeout=None) 从队列中取得元素，如果给定了block（非0）则一直阻塞到有可用的元素为止
    get_nowait() 和get(False)相同
    task_done() 用于表示队列的某一个元素已执行完成，该方法会被join()使用
    join() 在队列中所有元素执行完毕并调用上面的task_done()信号之前，保持阻塞
    
    线程的替代方案
    通常来说线程是一个好东西。不过由于Python的GIL限制，多线程更适合I/O密集型应用，而不是计算密集型应用。为了更好的并行性，需要使用多线程，以便让CPU的其他内核来执行。
    subprocess 模块
    这是派生进程的主要替代方案，可以单纯的执行任务，或者通过标准文件(stdin、stdout、stder)进行进程间通信
    
    multiprocessing模块
    允许为多核或多核CPU派生进程，其接口与threading模块非常相似。该模块同样也包括在共享任务的进程间传输数据的多种方式。
    
    concurrent.futures模块
    只在任务级别进行操作，也就是说，不再需要过分关注同步和线程/进程的管理。只需要指定一个给定了“worker”数量的线程/进程池，提交任务，然后整理结果。
    